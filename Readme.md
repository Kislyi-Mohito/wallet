это команда записывает в файл название всех библиотек
pip freeze > requirements.txt
pip install -r requirements.txt

нужно создать файл .gitignore это нужно что git игнорировал все папки что в этом файле
----Пример------
.idea
venv
__pycache__
----------------------------------------------------------------------------------------
Весь этот пункт описывается в гитхабе когда созаешь новую папку
создаем локальный репозиторий 
git init
теперь работ с гит хаб
git remote add origin https://github.com/Kislyi-Mohito/wallet.git соединнение репозитория
git push -u origin master надо каждый раз пушить после __комита__

----------------------------------------
если новая система
надо установить chockolatie
в win power shell

Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
choco install git
чтоб скопировать приложение на ноут 
git clone __ссылка на приложение в гитхаб__
___________________________________________
чтоб подттянуть изменения с другого ноутбука комагда
git pull
---------------------------------------------------
test commit of pull request
test commit of pull response
--------------------------------------------------------------------------------------------
FROM python:3-slim-buster  мы устонавливаем образ(ОС + приложения)

LABEL maintainer="nedenis.ste@gmail.com"  Моя подпись

WORKDIR /wallet_app         Создание корневой папки проекта (должна отличатся от самой папки проекта)

ENV PYTHONPATH=/wallet_app   указываю что эта папка является корневой

RUN python3 -m venv venv     создаю виртуаьную среду 

RUN /wallet_app/venv/bin/pip install --no-cache-dir pyarrow==13.0.0     устанавливаю необходимые библиотеки для работы контейнера

COPY requirements.txt /wallet_app/requirements.txt              копирую список библиотек в в папку проекта

RUN /wallet_app/venv/bin/pip install --no-cache-dir -r /wallet_app/requirements.txt      устанавливаю бибоиотеки из папки которую скопировал для работы проекта

COPY wallet /wallet_app/wallet      копирую сам проект на Джанго

CMD python /wallet_app/wallet/manage.py runserver   Запускаю его

------------------------------------------------------------------------------------------------------------------
[то что выше написано не работает, там надо все переписать]
[половина настроек выполнена в ФАЙЛЕ docker-compose.yml]
-------------------------------DOCKER ----------------------------------------------------------------------
Тут сейчас будет непонятно, я запишу запросы, которые помогли запустить, чуть позже их разберу
основные 

[я создал новую базу данных внутри контейнера]
__контейнер__

____
|  docker-compose down --> удалить контейнер
|  docker-compose up -d --build --> создать контейнер
____

docker-compose up -d --build --> запустить все контейнеры

docker-compose ps --> статус контейнеров

docker-compose exec db psql -U postgres -d wallet --> команда для подключения к базе данных. 
__db__ - название контейнера, __wallet__ - название базы данных  можно подключиться и писать SQL запосы, так и настроить базу данных но для этого ее нужно 
сначало создать и мигрировать, там команда была какая то

docker-compose up -d - запускает контейнеры в фоновом режиме (понятия не имею что это значит)

docker-compose logs db --> показывает логи  '''можно проверить  на наличие ошибок'''

docker-compose up -d --build
Флаг -d запускает контейнеры в фоновом режиме, а --build пересобирает их, если были изменения в конфигурации.

---------------------------------------------------------------------------------------------------------
[описане текщего dockerfile]   `я скачивал скрипт wait-for-it.sh`  [чтоб моя база данных смогла запустиься, непомню как он работает]

Этот Dockerfile описывает шаги для создания Docker-образа Python-приложения на Django, которое зависит от PostgreSQL. Разберем каждый шаг:

1. **`FROM python:3.11-slim`**  
   Это базовый образ для контейнера. Здесь выбирается облегченная версия Python 3.11 (`slim`), которая содержит только минимальные компоненты, необходимые для запуска Python. Это уменьшает размер образа и ускоряет его сборку.

2. **`WORKDIR /wallet_app`**  
   Устанавливает рабочую директорию внутри контейнера, куда будут копироваться файлы и запускаться команды. Это значит, что все последующие команды будут выполняться в `/wallet_app`.

3. **`RUN apt-get update && apt-get install -y libpq-dev gcc curl && apt-get clean`**  
   Этот шаг выполняет несколько команд, соединенных оператором `&&`:
   - `apt-get update` обновляет информацию о пакетах, доступных для установки, что позволяет установить самые свежие версии.
   - `apt-get install -y libpq-dev gcc curl` устанавливает необходимые зависимости:
     - `libpq-dev` — библиотека, необходимая для взаимодействия Python с PostgreSQL.
     - `gcc` — компилятор, который может потребоваться для установки Python-библиотек, требующих компиляции.
     - `curl` — утилита для передачи данных с удаленных серверов, которая используется позже для загрузки скрипта.
   - `apt-get clean` очищает кэш установленных пакетов, что уменьшает размер Docker-образа.

4. **`COPY requirements.txt .`**  
   Копирует файл `requirements.txt` из локального каталога в текущую рабочую директорию контейнера (`/wallet_app`). Этот файл содержит список зависимостей Python, необходимых для работы приложения.

5. **`RUN pip install --no-cache-dir -r requirements.txt`**  
   Устанавливает зависимости, указанные в `requirements.txt`, используя пакетный менеджер `pip`. Опция `--no-cache-dir` предотвращает кеширование установленных пакетов, чтобы уменьшить размер образа.

6. **`COPY . .`**  
   Копирует все файлы и каталоги из текущей локальной директории в рабочую директорию контейнера `/wallet_app`. Это копирует все файлы проекта, необходимые для его работы.

7. **`RUN curl -o wait-for-it.sh https://raw.githubusercontent.com/vishnubob/wait-for-it/master/wait-for-it.sh && chmod +x wait-for-it.sh`**  
   - `curl -o wait-for-it.sh` загружает скрипт `wait-for-it.sh`, сохраняет его в файле `wait-for-it.sh` в текущей директории. Этот скрипт помогает убедиться, что база данных PostgreSQL доступна перед запуском приложения.
   - `chmod +x wait-for-it.sh` устанавливает права на выполнение для этого файла, позволяя его запускать.

8. **`CMD ["./wait-for-it.sh", "db:5432", "--", "python", "wallet/manage.py", "runserver", "0.0.0.0:8000"]`**  
   Определяет команду, которая будет выполняться при запуске контейнера:
   - `./wait-for-it.sh db:5432` проверяет доступность сервиса базы данных на хосте `db` и порту `5432`. Этот хост обычно задается в настройках Docker Compose, связывая контейнеры с приложением и базой данных.
   - После успешной проверки доступности базы данных запускается команда `python wallet/manage.py runserver 0.0.0.0:8000`, которая запускает сервер Django на всех IP-адресах контейнера (`0.0.0.0`) и порту `8000`.

Этот Dockerfile полностью готовит контейнер для запуска Django-приложения, ожидая готовности базы данных PostgreSQL перед стартом.
---------------------------------------------------------------------------------------------------------------------------------
[ТУТ ОПИСАНИЕ ФАЙЛА docker-compose.yml][голубой цвет]

Этот файл `docker-compose.yml` описывает конфигурацию для запуска двух контейнеров: веб-приложения на Django и базы данных PostgreSQL. Давайте разберем каждую строку:

1. **`version: '3.8'`**  
   Определяет версию синтаксиса Docker Compose. Версия 3.8 используется для совместимости с новыми функциями Docker Compose.

2. **`services:`**  
   Определяет раздел, где описываются все сервисы (контейнеры) в приложении. В данном случае их два: `web` и `db`.

### Описание сервиса `web`
3. **`web:`**  
   Название первого сервиса. Этот сервис отвечает за веб-приложение на Django.

4. **`build: .`**  
   Указывает, что Docker Compose должен собрать образ для этого сервиса из текущей директории (`.`), используя `Dockerfile` в этом каталоге.

5. **`command: ["./wait-for-it.sh", "db:5432", "--", "python", "wallet/manage.py", "runserver", "0.0.0.0:8000"]`**  
   Задает команду для запуска в контейнере `web`:
   - `./wait-for-it.sh db:5432 --` — использует скрипт `wait-for-it.sh`, чтобы убедиться, что база данных `db` доступна на порту `5432`.
   - `python wallet/manage.py runserver 0.0.0.0:8000` — запускает сервер Django, доступный по адресу `0.0.0.0` и порту `8000` внутри контейнера.

6. **`ports:`**  
   Открывает порты контейнера для внешнего доступа.

7. **`- "8000:8000"`**  
   Прокидывает порт `8000` из контейнера `web` на порт `8000` хост-машины, чтобы веб-приложение было доступно по адресу `localhost:8000`.

8. **`volumes:`**  
   Определяет тома, позволяя монтировать локальные файлы в контейнер.

9. **`- .:/wallet_app`**  
   Монтирует текущую директорию на хосте (`.`) в рабочую директорию контейнера (`/wallet_app`). Это позволяет моментально отражать изменения в коде на хосте в контейнере.

10. **`depends_on:`**  
    Указывает зависимости, чтобы задать порядок запуска контейнеров.

11. **`- db  # Указываем, что сервис web зависит от db`**  
    Говорит, что контейнер `web` зависит от контейнера `db`. Docker Compose сначала запустит `db`, а затем — `web`.

### Описание сервиса `db`
12. **`db:`**  
    Название второго сервиса, который представляет базу данных PostgreSQL.

13. **`image: postgres:13`**  
    Использует официальный образ PostgreSQL версии 13.

14. **`environment:`**  
    Задает переменные окружения для настройки PostgreSQL.

15. **`POSTGRES_DB: "wallet"`**  
    Создает базу данных с именем `wallet`.

16. **`POSTGRES_USER: "postgres"`**  
    Задает имя пользователя для PostgreSQL, в данном случае `postgres`.

17. **`POSTGRES_PASSWORD: '00000'`**  
    Устанавливает пароль для пользователя PostgreSQL (`postgres`). В данном примере пароль равен `'00000'`.

18. **`ports:`**  
    Прокидывает порты для подключения к PostgreSQL.

19. **`- "5432:5432"`**  
    Прокидывает порт `5432` PostgreSQL на порт `5432` хост-машины, позволяя подключаться к базе данных через `localhost:5432`.

Этот `docker-compose.yml` файл настраивает контейнеры для запуска Django-приложения с PostgreSQL, обеспечивая связь между ними и упрощая их запуск.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------